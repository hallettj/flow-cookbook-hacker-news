{"version":3,"sources":["index.js.flow"],"names":[],"mappings":";;;;;;;uDA2EO,iBAAgC,CAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACe,gBADf;;AAAA;AACC,iBADD;AAEC,mBAFD,GAEW,EAFX;;AAGL,iBAAS,CAAT,GAAa,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AAC1B,sBAAQ,IAAR,CAAa,UAAU,QAAQ,CAAlB,CAAb;AACD;AALI,6CAME,QAAQ,GAAR,CAAY,OAAZ,CANF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,gB;;;;;;wDAmBf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACqB,iBAAiB,EAAjB,CADrB;;AAAA;AACC,uBADD;;AAEL,wBAAY,OAAZ,CAAoB,gBAAQ;AAC1B,sBAAQ,GAAR,CAAY,WAAW,IAAX,IAAmB,IAA/B;AACD,aAFD;;AAFK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,I;;;;;;wDAYf;AAAA,QAA+B,KAA/B,SAA+B,KAA/B;AAAA;AAAA;AAAA;AAAA;AAAA;AACC,oBADD,GACY,MAAM,GAAN,CAAU,SAAV,CADZ;AAAA;AAAA,mBAEe,QAAQ,GAAR,CAAY,QAAZ,CAFf;;AAAA;AAEC,iBAFD;AAAA,8CAGE,QAAQ,KAAR,EAAe;AAAA,qBACpB,KAAK,IAAL,KAAc,SAAd,GAA0B,CAAC,IAAD,CAA1B,GAAmC,EADf;AAAA,aAAf,CAHF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,a;;;;;;wDAQtB,kBAA2B,IAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACM,KAAK,IAAL,KAAc,MADpB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAIuB,cAAc,IAAd,CAJvB;;AAAA;AAIU,gBAJV;;AAKI,uBAAW,IAAX,EAAiB,IAAjB;AALJ;AAAA;;AAAA;AAOO,gBAAI,KAAK,IAAL,KAAc,SAAlB,EAA6B;AAChC;AACD,aAFI,MAGA;AACH,sBAAQ,GAAR,CAAY,WAAW,IAAX,IAAmB,IAA/B;AACD;;AAZH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,W;;;;;;wDAeR;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACqB,iBAAiB,EAAjB,CADrB;;AAAA;AACC,uBADD;AAAA;AAAA;AAAA;AAAA;AAAA,wBAEc,WAFd;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEM,gBAFN;AAAA;AAAA,mBAGG,YAAY,IAAZ,CAHH;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,Y;;;;;AAQtB;;;wDAEO,kBAA+B,CAA/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACkB,mEACpB,IADoB,CACf;AAAA,qBAAO,IAAI,IAAJ,EAAP;AAAA,aADe,CADlB;;AAAA;AACC,oBADD;AAAA;AAAA,mBAGiB,QAAQ,GAAR,CACpB,SAAS,KAAT,CAAe,CAAf,EAAiB,CAAjB,EAAoB,GAApB,CAAwB,UAAxB,CADoB,CAHjB;;AAAA;AAGC,mBAHD;AAAA,8CAME,IAAI,OAAJ,CANF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,e;;;;;AAStB;;;;wDACA,kBAA0B,EAA1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACqB,UAAU,EAAV,CADrB;;AAAA;AACQ,gBADR;;AAAA,kBAEM,KAAK,IAAL,KAAc,OAFpB;AAAA;AAAA;AAAA;;AAAA,8CAGW,IAHX;;AAAA;AAAA,8CAMW,IANX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,U;;;;;;yDAuBf,kBAA4B,EAA5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACqB,UAAU,EAAV,CADrB;;AAAA;AACQ,gBADR;;AAAA,kBAEM,KAAK,IAAL,KAAc,SAFpB;AAAA;AAAA;AAAA;;AAAA,8CAGW,IAHX;;AAAA;AAAA,8CAMW,QAAQ,MAAR,CAAe,IAAI,KAAJ,WAAkB,EAAlB,eAA8B,KAAK,IAAnC,qBAAf,CANX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAe,Y;;;;;AAWf;;AAEA;AACA;AACA;;;QAzJgB,S,GAAA,S;QA+HA,a,GAAA,a;;;;AA/JhB;AAEA,IAAM,YAA0B,QAAQ,YAAR,CAAhC;;AAWA;;;AAOA;;;AAOA;AAKO,SAAS,SAAT,CAAmB,EAAnB,EAA0C;AAC/C,SAAO,0DAAwD,EAAxD,YACJ,IADI,CACC;AAAA,WAAO,IAAI,IAAJ,EAAP;AAAA,GADD,CAAP;AAED;;AAED,SAAS,QAAT,CAAkB,IAAlB,EAAuC;AACrC,MAAI,KAAK,IAAL,KAAc,OAAlB,EAA2B;AACzB;AACA;AACA;AACA,WAAO,KAAK,KAAZ;AACD;AACF;;AAED,SAAS,UAAT,CAAoB,IAApB,EAAwC;AACtC,UAAQ,KAAK,IAAb;AACE,SAAK,OAAL;AACE,mBAAW,KAAK,KAAhB,uBAAuC,KAAK,EAA5C;AACF,SAAK,KAAL;AACE,aAAU,KAAK,EAAf,gBAA4B,KAAK,KAAjC;AACF,SAAK,KAAL;AACE,+BAAuB,KAAK,KAA5B;AACF,SAAK,MAAL;AACE,UAAM,UAAU,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAtB,GAA+B,CAA/C;AACA,yBAAiB,KAAK,KAAtB,0BAAgD,OAAhD;AACF,SAAK,SAAL;AACE,+BAAuB,KAAK,IAA5B;AACF,SAAK,SAAL;AACE,aAAU,KAAK,EAAf,oBAAgC,KAAK,IAAL,CAAU,KAAV,CAAgB,CAAhB,EAAkB,EAAlB,CAAhC;AACF;AACE,YAAM,IAAI,KAAJ,yBAAgC,KAAK,IAArC,CAAN;AAfJ;AAiBD;;AAED;AACA;AACA,SAAS,cAAT,GAAuC;AACrC,SAAO,gEACJ,IADI,CACC;AAAA,WAAO,IAAI,IAAJ,EAAP;AAAA,GADD,CAAP;AAED;;AAWD,SAAS,mBAAT,CAA6B,IAA7B,EAAkD;AAChD,UAAQ,KAAK,IAAb;AACE,SAAK,OAAL;AACA,SAAK,KAAL;AACA,SAAK,KAAL;AACA,SAAK,MAAL;AACE,aAAO,KAAK,KAAZ;AALJ;AAOD;;AASD,SAAS,UAAT,QAAyC,IAAzC,EAAkE;AAAA,MAA5C,EAA4C,SAA5C,EAA4C;AAAA,MAAxC,KAAwC,SAAxC,KAAwC;;AAChE,MAAM,WAAc,EAAd,0BAAqC,KAArC,MAAN;AACA,SAAO,WAAW,IAAX,GAAkB,KAAK,GAAL,CAAS;AAAA,oBAAc,IAAI,IAAlB;AAAA,GAAT,EAAmC,IAAnC,CAAwC,IAAxC,CAAzB;AACD;;AAyDM,SAAS,aAAT,SAA0E;AAAA,MAAjD,IAAiD,UAAjD,IAAiD;;AAC/E,MAAI,CAAC,IAAL,EAAW;AACT,WAAO,QAAQ,OAAR,CAAgB,EAAhB,CAAP;AACD;AACD,SAAO,QAAQ,GAAR,CAAY,KAAK,GAAL;AAAA,2DAAS,kBAAe,EAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBACJ,aAAa,EAAb,CADI;;AAAA;AACpB,qBADoB;AAAA;AAAA,qBAEP,cAAc,OAAd,CAFO;;AAAA;AAEpB,kBAFoB;AAAA,gDAGnB,EAAE,gBAAF,EAAW,UAAX,EAHmB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAT;;AAAA;AAAA;AAAA;AAAA,MAAZ,CAAP;AAKD;;AAkBD,SAAS,OAAT,CAAuB,EAAvB,EAAgC,EAAhC,EAAwD;AACtD,MAAM,SAAS,EAAf;AADsD;AAAA;AAAA;;AAAA;AAEtD,0BAAgB,EAAhB,mIAAoB;AAAA,UAAT,GAAS;;AAClB,aAAO,IAAP,CAAY,KAAZ,CAAkB,MAAlB,EAA0B,GAAG,GAAH,CAA1B;AACD;AAJqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKtD,SAAO,MAAP;AACD;;AAED;AACA,SAAS,GAAT,CAAgB,EAAhB,EAAyC;AACvC,SAAO,QAAQ,EAAR,EAAY;AAAA,WAAK,IAAI,CAAC,CAAD,CAAJ,GAAU,EAAf;AAAA,GAAZ,CAAP;AACD","file":"index.js","sourcesContent":["/* @flow */\n\n// The `typeof fetch` works because Flow has built-in type definitions for\n// a global `fetch` function.\nconst nodeFetch: typeof fetch = require('node-fetch')\n\nexport type Item = Story | Ask | Job | Poll | PollOpt | Comment\n\nexport type Story   = { type: 'story', kids?: ID[], url: URL }                 & ItemCommon & TopLevel\nexport type Ask     = { type: 'ask',  kids?: ID[], text: string, url: URL }    & ItemCommon & TopLevel\nexport type Job     = { type: 'job', text: string, url: URL }                  & ItemCommon & TopLevel\nexport type Poll    = { type: 'poll', kids?: ID[], parts: ID[], text: string } & ItemCommon & TopLevel\nexport type PollOpt = { type: 'pollopt', parent: ID, score: number, text: string } & ItemCommon\nexport type Comment = { type: 'comment', kids?: ID[], parent: ID, text: string }   & ItemCommon\n\n// Fields common to all item types\ntype ItemCommon = {\n  by:   Username,\n  id:   ID,\n  time: number,\n}\n\n// Fields common to top-level item types\ntype TopLevel = {\n  descendents: number,\n  score: number,\n  title: string,\n}\n\n// These type aliases just help to illustrate the purpose of certain fields\nexport type Username = string\nexport type ID = number\nexport type URL = string\n\nexport function fetchItem(id: ID): Promise<Item> {\n  return nodeFetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)\n    .then(res => res.json())\n}\n\nfunction getTitle(item: Item): ?string {\n  if (item.type === 'story') {\n    // This works because this line is only reachable if the type of\n    // `item.type` is `'story'`, which means that `item` can be expected to\n    // have a `title` property.\n    return item.title\n  }\n}\n\nfunction formatItem(item: Item): string {\n  switch (item.type) {\n    case 'story':\n      return `\"${item.title}\" submitted by ${item.by}`\n    case 'ask':\n      return `${item.by} asked: ${item.title}`\n    case 'job':\n      return `job posting: ${item.title}`\n    case 'poll':\n      const numOpts = item.kids ? item.kids.length : 0\n      return `poll: \"${item.title}\" - choose one of ${numOpts} options`\n    case 'pollopt':\n      return `poll option: ${item.text}`\n    case 'comment':\n      return `${item.by} commented: ${item.text.slice(0,60)}...`\n    default:\n      throw new Error(`unknown item type: ${item.type}`)\n  }\n}\n\n// Fetches the largest ID, which should be the ID of the most recently-created\n// item.\nfunction fetchMaxItemId(): Promise<ID> {\n  return nodeFetch(`https://hacker-news.firebaseio.com/v0/maxitem.json`)\n    .then(res => res.json())\n}\n\nexport async function fetchLatestItems(n: number): Promise<Item[]> {\n  const maxId = await fetchMaxItemId()\n  const fetches = []\n  for (let i = 0; i < n; i++) {\n    fetches.push(fetchItem(maxId - i))\n  }\n  return Promise.all(fetches)\n}\n\nfunction getTitleCowboyStyle(item: Item): ?string {\n  switch (item.type) {\n    case 'story':\n    case 'ask':\n    case 'job':\n    case 'poll':\n      return item.title\n  }\n}\n\nexport async function main() {\n  const latestItems = await fetchLatestItems(15)\n  latestItems.forEach(item => {\n    console.log(formatItem(item) + \"\\n\")\n  })\n}\n\nfunction formatPoll({ by, title }: Poll, opts: PollOpt[]): string {\n  const headline = `${by} started a poll: \"${title}\"`\n  return headline + \"\\n\" + opts.map(opt => `  - ${opt.text}`).join(\"\\n\")\n}\n\nexport async function fetchPollOpts({ parts }: Poll): Promise<PollOpt[]> {\n  const promises = parts.map(fetchItem)\n  const items = await Promise.all(promises)\n  return flatMap(items, item => (\n    item.type === 'pollopt' ? [item] : []\n  ))\n}\n\nasync function displayItem(item) {\n  if (item.type === 'poll') {\n    // At this point the type of `item` has been narrowed so that we can pass it\n    // to specialized functions.\n    const opts = await fetchPollOpts(item)\n    formatPoll(item, opts)\n  }\n  else if (item.type === 'pollopt') {\n    // do nothing\n  }\n  else {\n    console.log(formatItem(item) + \"\\n\")\n  }\n}\n\nexport async function betterClient() {\n  const latestItems = await fetchLatestItems(15)\n  for (const item of latestItems) {\n    await displayItem(item)\n  }\n}\n\n\n/* Additional Hacker News API endpoints */\n\nexport async function fetchTopStories(n: number): Promise<Story[]> {\n  const storyIds = await nodeFetch(`https://hacker-news.firebaseio.com/v0/topstories.json`)\n    .then(res => res.json())\n  const results = await Promise.all(\n    storyIds.slice(0,n).map(fetchStory)\n  )\n  return nub(results)\n}\n\n// Fetch an item, but resolve to `null` if the item is not a story.\nasync function fetchStory(id: ID): Promise<?Story> {\n  const item = await fetchItem(id)\n  if (item.type === 'story') {\n    return item\n  }\n  else {\n    return null\n  }\n}\n\nexport type CommentTree = { comment: Comment, kids: CommentTree[] }\n\nexport function fetchComments({ kids }: Story | Comment): Promise<CommentTree[]> {\n  if (!kids) {\n    return Promise.resolve([])\n  }\n  return Promise.all(kids.map(async function(id) {\n    const comment = await fetchComment(id)\n    const kids = await fetchComments(comment)\n    return { comment, kids }\n  }))\n}\n\nasync function fetchComment(id: ID): Promise<Comment> {\n  const item = await fetchItem(id)\n  if (item.type === 'comment') {\n    return item\n  }\n  else {\n    return Promise.reject(new Error(`item ${id} is an ${item.type}, not a comment`))\n  }\n}\n\n\n/* helpers */\n\n// Provides flexible array processing - this function can be used to remove\n// items from an array, to replace individual items with multiple items in the\n// output array, or pretty much anything you might need.\nfunction flatMap<A, B>(xs: A[], fn: (x: A) => B[]): B[] {\n  const result = []\n  for (const x of xs) {\n    result.push.apply(result, fn(x))\n  }\n  return result\n}\n\n// Removes `null` or `undefined` values from an array\nfunction nub<A>(xs: Array<?A>): Array<A> {\n  return flatMap(xs, x => x ? [x] : [])\n}\n"]}